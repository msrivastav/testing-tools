package me.msri.buildtool.gradle;

import java.io.ByteArrayOutputStream;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Optional;
import java.util.concurrent.CountDownLatch;
import lombok.experimental.UtilityClass;
import lombok.extern.slf4j.Slf4j;
import me.msri.buildtool.BuildToolInformationRepository;
import me.msri.buildtool.exception.BuildToolRunnerException;
import org.gradle.tooling.GradleConnectionException;
import org.gradle.tooling.ResultHandler;

@UtilityClass
@Slf4j
public class GradleRunnerUtil {

  /**
   * Executes a gradle task for a project and returns the generated output or error as a string.
   *
   * @param fullProjectPath Absolute path of the project.
   * @return A {@link Map.Entry} containing output or error as string that was generated by running
   *     supplied gradle task.
   */
  public static Map.Entry<String, String> executeTask(
      final GradleClientProvider gradleClientProvider,
      final String fullProjectPath,
      final String task) {
    final long startTime = System.currentTimeMillis();
    final var outputStream = new ByteArrayOutputStream();
    final var errorStream = new ByteArrayOutputStream();

    try (final var projConn = gradleClientProvider.getConnectionForProject(fullProjectPath)) {
      final var latch = new CountDownLatch(1);
      projConn
          .newBuild()
          .setStandardOutput(outputStream)
          .setStandardError(errorStream)
          .forTasks(task)
          .run(
              new ResultHandler<>() {
                @Override
                public void onComplete(Void result) {
                  log.info(
                      "Task: '{}' execution complete in time: {}ms",
                      task,
                      (System.currentTimeMillis() - startTime));
                  latch.countDown();
                }

                @Override
                public void onFailure(GradleConnectionException failure) {
                  log.error(
                      "Task: '{}' execution failed in time: {}",
                      task,
                      (System.currentTimeMillis() - startTime));
                  latch.countDown();
                  throw new BuildToolRunnerException(failure);
                }
              });
      latch.await();
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new BuildToolRunnerException(e);
    }

    return Map.entry(outputStream.toString(), errorStream.toString());
  }

  /**
   * Executes a gradle task if it is configured for the given project.
   *
   * @return A {@link Map.Entry} containing output or error as string that was generated by running
   *     supplied gradle task.
   */
  public static Optional<Entry<String, String>> executeTaskAndProcessError(
      final GradleClientProvider gradleClientProvider,
      final BuildToolInformationRepository repository,
      final String projectName,
      final String gradleTask) {

    if (!repository.isTaskConfiguredForProject(projectName, gradleTask)) {
      log.warn("Task: '{}', not configured for project: {}", gradleTask, projectName);
      return Optional.empty();
    }

    final String projectPath = repository.getAbsolutePathOfProject(projectName);
    final var result = executeTask(gradleClientProvider, projectPath, gradleTask);

    return Optional.of(result);
  }
}
